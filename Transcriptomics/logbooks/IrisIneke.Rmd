---
title: "IrisIneke.Rmd"
author: "Iris Ineke"
date: "2024-10-17"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Presentatie voorbereiden
(Zondag 13 oktober)

Ik moet voor het plan van aanpak de samples uitzoeken. De verschillende
samples:

-   Baseline_RNAseq (4)

-   NonTreated_RNAseq (6)

-   Treated_RNAseq (6)

-   NSG_Baseline_000_RNAseq (5)

-   NSG_Non-Treatment_000_RNAseq (5)

-   NSG_Entinostat_000_RNAseq (5)

-   Baseline_TCRseq (6)

-   NonTreated_TCRseq (6)

-   Treated_TCRseq (6)

Er zijn dus drie groepen:

-   RNAseq
-   NSG_RNAseq
-   TCRseq

en elke groep bestaat uit:

-   Baseline
-   Non_treated
-   Treated

De sample nummers van de TCRseq en de RNAseq zijn allebei in de 400, Dus
ik vermoed dat ze twee sequence techieken op dezelfde samples hebben
uitgevoerd.

Wat is het verschil tussen de TCRseq, RNAseq en NSG_RNAseq:

-   RNAseq: meet de genexpressie (onder bepaalde omstandigheden)
-   TCRseq: meet de reactie van het immuumsysteem (door te kijken naar
    de hoeveelheid T-celreceptors ( cellen die het antigenen herkennen))
-   NSG_RNAseq: NSG-muizen zijn muizen die een zwak immuumsysteem hebben
    en daardoor gebruikt worden om menselijke cellen in te enten (zonder
    dat het immuumsysteem van de muis ze afstoot).

Wat is het verschil tussen de Baseline, Non_treated en Treated:

-   Baseline is voor de tumor
-   Non_treated is na de tumor zonder entinostat
-   Treated is na de tumor met entinostat

quality control: welke tools gaan we gebruiken en waarom: - trimmomatic:
om de lage kwaliteit reads van het sequencen eruit te halen. Waarom: Om
foutieve conclusies door foutieve data later te voorkomen (als je data
gebruikt die niet klopt, trek je uit die data ook conclusies die niet
overeenkomen met de werkelijkheid). - fastqc: geeft een rapport met de
kwaliteit van de data. Waarom: Hieruit kun je bepalen wat je eventueel
wilt aanpassen met Trimmomatic. - multiqc: voegt alle fastqc rapporten
van samples samen tot een rapport. Waarom: Zo kun je makkelijker de
resultaten van fastqc van alle samples bekijken.

! Presenteren:

-   samples met nsg enzo (tabel leveren aan Ramon)
-   quility control (bulletpoints: trimmomatic, fastqc, multiqc)

(Maandag 14 oktober)

Alles uitgeschreven voor de presentatie en het plan van aanpak:\

Tabel van de samples (van de Transcriptomics):\

(!tabel doet raar met knitten)\


|                | **Baseline** | **Non_treated** | **Treated** | 
|----------------|--------------|-----------------|-------------| 
| **RNAseq**     |       4      |        6        |      6      | 
| **NSG_RNAseq** |       5      |        5        |      5      | 
| **TCRseq**     |       6      |        6        |      6      | 



**Samples**\
Er zijn voor het transcriptomics gedeelte in totaal 49 samples. Deze
samples bestaan uit drie groepen; RNAseq, NSG_RNAseq en TCRseq. En al
deze groepen bestaan uit baseline, non_treated en treated. De RNAseq en
de TCRseq zijn waarschijnlijk uitgevoerd op dezelfde samples, aangezien
de identificatienummers overeenkomen met elkaar. De NSG_RNAseq zijn een
andere soort samples. NSG staat in dit geval voor een soort muis die
gekweekt wordt en vaak voor onderzoek wordt gebruikt. Het immuunsysteem
van deze muis is namelijk zeer zwak of helemaal afwezig. Hierdoor is de
NSG-muis perfect om menselijke cellen in te enten, omdat het
immuunsysteem van de muis de cellen niet goed kan afbreken. Hierdoor
kunnen ze in het onderzoek kijken welk effect de mutatie op menselijke
cellen heeft zonder menselijke proefpersonen te hoeven gebruiken. Met de
RNA-sequencing wordt er gekeken naar de genexpressie onder bepaalde
omstandigheden. In dit geval dus zonder mutatie (baseline) met mutatie
(non_treated) en met mutatie en medicatie (treated). De TCR-sequencing
meet de reactie van het immuunsysteem door te kijken naar de hoeveelheid
T-celreceptors (cellen die het antigen herkennen).

**quality control**\
We gaan Fastqc en Multiqc gebruiken om te bepalen wat we willen
verbeteren aan de data. Dit doen we door middel van het rapport dat uit
Multiqc komt (wat een samenvatting maakt van alle rapporten die uit
Fastqc komen). Hierna gaan we Trimmomatic gebruiken om de lage kwaliteit
reads van het sequencen eruit te halen. Dit doen we om foutieve
conclusies door foutieve data later te voorkomen. Als je data gebruikt
die niet klopt, trek je immers (uit die data) ook conclusies die niet
overeenkomen met de werkelijkheid. Hierna voeren we nog een keer Fastqc
en Multiqc uit om te kijken of Trimmomatic voldoende verbeterd heeft.
Als er uit dit rapport blijkt dat de data nog niet genoeg is opgeschoond
zullen we nog een keer Trimmomatic moeten gebruiken totdat we tevreden
zijn.

 

## quality control:
(woensdag 16 oktober)
FastQC en multiQC uitgevoerd op de data (duurt erg lang, rekening mee
houden in planning).

Uit het multiqc rapport blijkt dat 'Per Base Sequence Content', 'Per
Sequence GC Content' en 'Sequence Duplication Levels' verbeterd kunnen
worden.

Trimmomatic uitgevoerd (instellingen zijn op basis van multiqc 'Sequence
Quality Histograms' plot):

```{bash Trim1, eval=FALSE}
cat /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/SRR_Acc_List.txt | \
  parallel 'TrimmomaticPE -threads 8 ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/fastq/{}_1.fastq' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/fastq/{}_2.fastq' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic2/{}_paired.1.fastq ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic2/{}_unpaired.1.fastq ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic2/{}_paired.2.fastq ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic2/{}_unpaired.2.fastq ' \
                  'ILLUMINACLIP:/students/2024-2025/Thema05/BlaasKanker/tools/trim_adapters/TruSeq3-PE.fa:2:30:10 ' \
                  'LEADING:30' \
                  'TRAILING:25'
```

Weer fastqc en multiqc gerund. De unpaired moeten niet worden meegenomen
in de analyse (dit zorgde namelijk voor een erg chaotisch multiqc
rapport). En threads meegeven, zodat het niet 3 uur duurt.

```{bash fastqc, eval=FALSE}
fastqc /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic2/*_paired.*  \
  -o /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/fastqc_after_trim2.2 -t 12
```

Trimmomatic met andere (strengere) settings gerund na overleg met de
groep:

```{bash trim2, eval=FALSE}
cat /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/SRR_Acc_List.txt | \
  parallel 'TrimmomaticPE -threads 10 ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/fastq/{}_1.fastq' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/fastq/{}_2.fastq' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic3/{}_paired.1.fastq ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic3/{}_unpaired.1.fastq ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic3/{}_paired.2.fastq ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic3/{}_unpaired.2.fastq ' \
                  'ILLUMINACLIP:/students/2024-2025/Thema05/BlaasKanker/tools/trim_adapters/TruSeq3-PE.fa:2:30:10 ' \
                  'LEADING:32' \
                  'TRAILING:30'
```

In plaats van het fastqc rapport 'fastp' gebruikt op aanraden van Ramon,
omdat deze veel sneller gaat.

```{bash fastp, eval=FALSE}
ls /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic3 | grep -i -E "*_paired*" | \
parallel "/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/tools/bin/falco /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic3/{} -o /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/fastqc_after_trim3/{}_fastqc_report"
```

Daar weer multiqc op gedaan.

```{bash multiqc, eval=FALSE}
multiqc /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/fastqc_after_trim3/* \
-o /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/multiqc_after_trim3
```

De adapter ontent is erg hoog. Deze proberen te verminderen met headcrop
(begin eraf halen).

```{bash trim_headcrop, eval=FALSE}
cat /students/2024-2025/Thema05/BlaasKanker/Transcriptomics/SRR_Acc_List.txt | \
  parallel 'TrimmomaticPE -threads 10 ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/fastq/{}_1.fastq' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/fastq/{}_2.fastq' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic3/{}_paired.1.fastq ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic3/{}_unpaired.1.fastq ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic3/{}_paired.2.fastq ' \
                  '/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/quality_control/trimmomatic3/{}_unpaired.2.fastq ' \
                  'ILLUMINACLIP:/students/2024-2025/Thema05/BlaasKanker/tools/trim_adapters/TruSeq3-PE.fa:2:30:10 ' \
                  'HEADCROP:7' \
                  'LEADING:32' \
                  'TRAILING:30'
```

Na advies van Marcel te hebben gevraagd over het aantal adapter content
die we hebben tot de conclusie gekomen dat we waarschijnlijk geen
Trimmomatic hoeven te gebruiken (data is al goed genoeg). 
(!kijk nog even naar de bron: https://pubmed.ncbi.nlm.nih.gov/33575617/)

We zijn erachter gekomen dat in de NGS muizen geen menselijke cellen
zitten. Dus deze moeten we ook mappen tegen het muis-ref-genoom (Wat wel heel gek
is is dat in het artikel staat dat ze alles tegen het menselijke-ref-genoom
hebben gemapt, is dit een fout ?).\

De mapping tegen het muis genoom ziet er beter uit, dus waarschijnlijk zit er een fout in het artikel.

## Deseq
(wo 30 oktober)
De volgende code is van [Ramon](https://github.com/RamonReilman/GenomicsTranscriptomics/blob/main/Transcriptomics/logbooks/RamonReilman.Rmd) (van Teams):
```{r}
file.names <- list.files('/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/mapping/',
                         pattern = '*_star_ReadsPerGene.out.tab')
 
## Function for reading in files
read_sample <- function(file.name) {
  ## Extract the sample name for naming the column (retaining the 'SRR....' part)
  sample.name <- strsplit(file.name, ".", fixed = TRUE)[[1]][1]
  sample <- read.table(file.name, header = FALSE, sep="\t", 
                       row.names = NULL, skip = 4)
  ## Rename the count column
  names(sample)[2] <- sample.name
  ## Return a subset containing the transcript ID and sample name columns
  return(sample[c(1, 2)])
}
 
```
 
```{r}
 
setwd('/students/2024-2025/Thema05/BlaasKanker/Transcriptomics/output/mapping/')
 
## Read the FIRST sample
counts <- read_sample(file.names[1])
 
## Read the remaining files and merge the contents
for (file.name in file.names[2:length(file.names)]) {
  sample <- read_sample(file.name)
  counts <- merge(counts, sample, by = 1)
}
 
# Set the row names to the transcript IDs
rownames(counts) <- counts$V1
counts <- counts[-1]
head(counts)
```
 
 
```{r}
 
col_data <- read.csv("/students/2024-2025/Thema05/BlaasKanker/etc/DSEQ_verwerking(Sheet1).csv", sep = ";")
rownames(col_data) <- col_data[,1]
col_data
```
 
 
## Annot count_data
Het annoteren van onze data zorgt ervoor dat de genen de NCBI naamgeving krijgen. Zo is het straks overzichtelijker om informatie te vinden over de genen.
 
```{r}
library(dplyr)
library(tidyr)
 
col_data <- col_data %>%
    dplyr::group_by(strain, treatment) %>%
    dplyr::mutate(r_num = row_number()) %>%
    dplyr::ungroup() %>%
    mutate(condition = paste0(strain, "_", treatment, "_r", r_num))
head(col_data)
 
```
In de bestanden kon niks gevonden worden over de genen, maar zo is het wel duidelijker waar elke kolom voor staat.
Dat moet nu nog toegepast worden in de counts df
```{r}
 
for (i in 1:nrow(col_data)) {
  idx <- grep(file$Run[i], names(counts))
  names(counts)[idx] <- col_data$condition[i]
}
head(counts)
```
Nu zijn de SRR* namen vervangen met waar ze voor staan en is de df duidelijker te lezen, om straks makkelijker de kolommen op te halen die horen bij elk mogelijke variant groepeer ik deze.
 
```{r}
print(colnames(counts))
C57BL_Vehicle <- grep("C57BL/6_Vehicle", names(counts))
C57BL_Entinostat <- grep("C57BL/6_Entinostat", names(counts))
C57BL_Baseline <- grep("C57BL/6_Baseline", names(counts))
 
nsg_Vehicle <- grep("NSG_Vehicle", names(counts))
nsg_Entinostat <- grep("NSG_Entinostat", names(counts))
nsg_Baseline <- grep("NSG_Baseline", names(counts))
```
Nu kunnen deze variabelen gebruikt worden om de juiste kolommen te selecteren.
 
Dan kan dit nu samengevoegd worden met DESEQ, wat Janine heeft uitgezocht. Bekijk [Janine haar logboek](https://github.com/RamonReilman/GenomicsTranscriptomics/blob/main/Transcriptomics/logbooks/JaninePostmus.Rmd) voor meer informatie over de code.
 
```{r}
library(DESeq2)
# Making deseqdataset with counts en coldata
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = col_data,
                              design = ~ 0 + source_name)
head(dds)
```
 
```{r}
# Prefiltering on low gene counts
keep <- rowSums(counts(dds)) >= 10
ddst <- dds[keep,]
```
 
```{r}
 
# Setting factor level
#dds$treatment <- relevel(dds$treatment, ref = "Baseline")

dds$treatment <- factor(dds$treatment, levels = c("Baseline","Entinostat", "Vehicle"), )

```
 
```{r}
# Running deseq
dds <- DESeq(dds)
res <- results(dds)
```


## MA plot
Nu dit allemaal is uitgevoerd kunnen we verder met een MA plot te maken van nsg-baseline vs nsg-entinostat door gebruik te maken van de 'res' die is gemaakt.
Hierbij heb ik een[tutorial](https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#ma-plot) gebruikt.
```{r}
# ylim zijn de limieten van de y-as
plotMA(res, ylim=c(-2,2))
```

De plot bevat nog noise, dus we gaan de 'Log fold change shrinkage for visualization and ranking' uitvoeren van de tutorial.
 
```{r}
resultsNames(dds)
```

Bij coef wordt maar 1 input geaccepteerd, dus eerst de twee namen apart invullen van de situaties die we willen visualizeren:
```{r, eval=FALSE}
resLFC_Baseline <- lfcShrink(dds, coef="source_nameNSG_bladder.tumor_Baseline", type="apeglm")
resLFC_Baseline
```

```{r eval=FALSE}
resLFC_Entinostat <- lfcShrink(dds, coef="source_nameNSG_bladder.tumor_Entinostat", type="apeglm")
resLFC_Entinostat
```

Maar nu is de vraag hoe we dit samen moeten voegen ? Er een vector van maken werkt niet.

Ramon heeft een subset gemaakt gemaakt van de twee situaties, dit is handig om alleen de informatie van de situaties weer te geven in de plot:
```{r dds_subset}
dds_subset <- dds[, dds$source_name %in% c("NSG_bladder tumor_Entinostat", "NSG_bladder tumor_Baseline")]

# re-run DEseq on the subset data
dds_subset <- DESeqDataSet(dds_subset, design = ~ 0 + source_name)
dds_subset <- DESeq(dds_subset)

res_subset <- results(dds_subset)
```
Hiermee doorgaan:
Plot van alleen de baseline en Entinostat:
```{r plotMA_subset_before}
# omdat 2 in log-termen hoog is daar de limit zetten
plotMA(res_subset, ylim=c(-2,2))
```
Interpretatie plot: 
x-as is de counts en de y-as is de log verandering. \
Dus hoe verder op de x-as hoe meer counts van het gen is. En hoe verder op y-as hoe meer verschillend de expressie van het gen is. \
De genen die significant verschillen in expressie zullen dus de blauwe bolletjes zijn aan de rechterkant van de plot.

! Ramon heeft het probleem met de enkele input van lfcShrink opgeslost:
```{r dds_nsg_subset}
dds_nsg_subset <- dds[, c(nsg_Baseline,nsg_Entinostat)]
 
dds_nsg_subset <- DESeqDataSet(dds_nsg_subset, design = ~ treatment)
dds_nsg_subset$treatment <- relevel(dds_nsg_subset$treatment, ref = "Baseline")
dds_nsg_subset <- DESeq(dds_nsg_subset)
 
nsg_res <- results(dds_nsg_subset)
```

```{r resultsNames_subset}
resultsNames(dds_nsg_subset)
```
Dit lost het probleem op dat uit de resultsNames() eerder alle situaties apart kwamen. Nu zijn ze verdeeld in de situaties die wij wel willen gebruiken (treatment_Entinostat_vs_Baseline) en die wij niet willen gebruiken (Intercept) voor deze plot. \
Hierop kunnen we de lfcShrink wel goed uitvoeren:
```{r lfcShrink_subset}
resLFC_subset <- lfcShrink(dds_nsg_subset, coef="treatment_Entinostat_vs_Baseline", type="apeglm")
resLFC_subset
```
Dan kan nu de plot opnieuw gemaakt worden van de lfcSchrink subset:
```{r plotMA_resLFCsubset_after}
# omdat 2 in log-termen hoog is daar de limit zetten
plotMA(resLFC_subset, ylim=c(-2,2))
```
Dit is echt veel beter. Het is interessant om te kijken welke genen bij welke punten horen, dus we gaan proberen om de genen erbij te zetten. 
Hiervoor is een [online artikel](https://www.r-bloggers.com/2016/01/repel-overlapping-text-labels-in-ggplot2/) gebruikt.
```{r ggplot2_genen, fig.cap="MAplot van de log van de gen-expressie"}
#help("plotMA")

library(ggplot2)
library(ggrepel)

# data frame maken van resLFC_subset
ressub_df <- as.data.frame(resLFC_subset)

# voegt niewe kolom toe aan df met de genen 
# (de rownames zijn dus blijkbaar de genen, dus deze neemt hij)
ressub_df$gene <- rownames(ressub_df)

# MAplot met ggplot2 maken:
# x=baseMean : gemiddelde expressie op x-as
# y=log2FoldChange " expressie log-2 verandering op de y-as
ggplot(ressub_df, aes(x=baseMean, y=log2FoldChange)) +
    # geom_point voegt punten toe aan de plot
    # color = padj < 0.05 : kleurt alle punten met p-waarde hoger dan 0.05
    # alpha=0.5 : zorgt ervoor dat de punten doorzichtig zijn (beter af te lezen bij overlap)
    geom_point(aes(color = padj < 0.05), alpha=0.5) +
    # scale_x_log10() : zorgt ervoor dat de as naar log aangepast wordt (zoals de input data)
    scale_x_log10() +
  
    # de labels toevoegen aan de plot:
    # padj < 0.05 & !is.na(padj)) : voegt alleen label toe als p-waarde significant is
    # max.overlaps : minder maken voor leesbaarheid, maar laat dan niet meer alle genen zien
    # size : is dit leesbaar genoeg ? (ben mn bril kwijt, dus kan t zoiezo niet zien)
    geom_text_repel(data = subset(ressub_df, padj < 0.05 & !is.na(padj)),
                    aes(label = gene), 
                    size=1.2, 
                    max.overlaps = 50) +
    theme_minimal() +
    labs(x = "Base Mean", y = "Log2 Fold Change")
```
In de bovenstaande plot zie je de maplot die we eerder ook hadden, maar dan in ggplot2. Ook zijn de genen toegevoegd. De padj < 0.05 staat voor de p-waarde. Alles wat kleiner dan 0.05 is statistisch significant en wordt verder gebruikt. Dus alleen alles met een p-waarde kleiner dan 0.05 wordt een gen bijgezet (en blauw gekleurd). \
Zoals eerder vermeld is, zijn de punten rechts in de grafiek het interresants, omdat die genen significant verschillen in expressie.
(! genen opzoeken, literatuuronderzoek)

## Gen expressie vehicle vraag
Uit Ramon zijn plot bleek dat bij de NSG muis de vehicle een hoge genexpressie had op het gene-Ces4a. Dit gen zorgt voor de afbraak van xenobiotische stoffen. Onze theorie is dat de stof die de vehicle toegedient heeft gekregen een xenobiotische stof is, waardoor de vehicle een hoge expressie heeft van gene-Ces4a.
In [het artikel](https://pmc.ncbi.nlm.nih.gov/articles/PMC8363284/) staat de volgende zin: 'BBN963 cells were treated with DMSO or 1 μM entinostat for 72 hours in vitro.' Dit betekend dat de de stof waarschijnlijk DMSO is. Dit is een xenobiotische stof, dus dit kan de hoge genexpressie verklaren.
(! BRON_DMSO_IS_XENOBIOTISCHE_STOF: https://pubmed.ncbi.nlm.nih.gov/17177172/)


